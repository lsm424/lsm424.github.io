{"posts":[{"title":"树莓派装机","content":"1、下载镜像 一般选择从官方的镜像 Raspbian OS，但是官网的比较慢，一般选择国内镜像下载，有两个： TUNA镜像站 SJTUG镜像站 同一个版本的镜像分为三种： Raspberry Pi OS with desktop 即桌面版，1G左右大小，包含基本的软件 Raspberry Pi OS with desktop and recommended software即full版本，包含一些办公软件，会比较大，3G左右， Raspberry Pi OS Lite即轻量级版，不带桌面，不到500M 一般选择大小中等的桌面版，因为full版本太大，刷机时间以及磁盘占用都增加，包含的软件一般实际用不到，除非真的是办公使用，而轻量级版本缺少桌面，在一些配置方面不是很方面。常用的桌面版直达门： 2021-10-30 推荐版 2、下载刷镜像软件Raspberry Pi Imager 到官网下载刷机软件：https://www.raspberrypi.com/software/ 软件直达门 windows版本 mac版本 3、刷机 可以使用u盘或者sd卡刷机，对于这二者方式的刷机和启动没有任何区别。树莓派会优先从sd卡启动，没有的话就会使用usb接口启动。 3.1 刷机步骤： 将u盘或者tf卡插入电脑，启动上一步下载的Raspberry Pi Imager，选择刚插入的磁盘，再选择第一步下载的镜像，点击write，等待10分钟左右完成。 3.2 重新刷机 进入windows的磁盘管理或者使用diskgenius，清理分区（包括boot、root分区），重新新建分区，再格式化，最后再重新按照上一步刷机。 3.3 常见问题 3.3.1 刷机后我的磁盘怎么变小了 刷机后，windows你可能上看到十几个G的u盘或者sd卡只有200M了，不要惊慌！这是因为linux的分区在windows下看不到。装了Linux系统之后，SD卡会分成三种格式的分区，分别是：FAT32、EXT3、SWAP2。 Ext3区属于linux的文件系统，就和win的系统盘C盘一样 Swap区为linux的虚拟内存区，主要在物理内存不够用的时候，做缓存用的。 以上两个，是Linux系统的分区。 FAT32就是那“200M”了 3.3.2 到底用u盘还是sd卡呢 经验表明：使用tf卡会十分卡顿，第一次开机都要三四分钟，使用了ssd的移动硬盘接usb3.0速度超快，开机速度10秒左右，测试过ssd的读写速度如下： pi@raspberrypi:~ $ dd if=/dev/zero of=/tmp/output.img bs=4k count=256k 记录了262144+0 的读入 记录了262144+0 的写出 1073741824字节（1.1 GB，1.0 GiB）已复制，5.59087 s，192 MB/s pi@raspberrypi:~ $ dd if=/tmp/output.img bs=4k of=/dev/null 记录了262144+0 的读入 记录了262144+0 的写出 1073741824字节（1.1 GB，1.0 GiB）已复制，4.06454 s，264 MB/s 从上面测试结果可以看出，写入速度192MB/s，读取速度264MB/s！ 3.3.3 有时刷机出现“锁该卷时发生错误 错误5 拒绝访问” win+R进入cmd指向如下命令： 1、diskpart 2、list disk # 查看所有磁盘，找到u盘或者sd卡所在的磁盘编号 3、select disk 2 # 2要改成具体你所使用磁盘的编号 4、clean 4、启动并设置ssh 插入sd卡或者u盘，接上hdmi显示器，耐心等待一会（期间可能会有短暂黑屏），会出现桌面，第一次登录会引导设置语言、pi用户密码、wifi、以及软件更新（这一步建议跳过）. 5、设置ssh、vnc 设置ssh、vnc，方面后续无线连接进行开发 进入rasp-config 将下列ssh、vnc勾选，启动服务 ","link":"https://lsm424.github.io/post/shu-mei-pai-zhuang-ji/"},{"title":"map实现原理","content":"map使用Hash表作为底层实现，一个Hash表可以有多个bucket，而每个bucket保存了map中的一个或一组键值对 1、map的数据结构 map的数据结构由runtime/map.go:hmap 定义 type hmap struct { count int // 当前保存的元素 B uint8 // bucket数组的大小 buckets unsafe.Pointer // bucket数组，数组的长度为2的B次方 oldbuckets unsafe.Pointer // 老旧bucket数组，用于扩容 ... } 如下展示了一个拥有4个bucket的map 本例中，由于B=2，所以buckets数组的长读为4（2的2次方），元素通过hash运算后会落到谬个bucket中进行存储。 2、bucket的数据结构 bucket的数据结构由runtime/map.go：bmap 定义： type bmap struct { tophash [8]uint8 // 存储hash值的高8位 data []byte // key value数据：key/key/key/.../value/value/value... overflow *hmap // 溢出bucket的地址 } 每个bucket可以存储8个键值对。tophash是一个长度为8的整形数组，Hash值低位相同的键存入当前bucket时会将Hash值的高位存储在该数组中，以便后续匹配。 data存key value数据，它的存放顺序是为了节省字节对齐带来的空间浪费。overflow指针指向的是下一个bucket，据此将所有冲突的键连接起来。 下图展示了bucket存放了8个key-value对 3、Hash冲突 当两个相同key被Hash到同一个bucket时，我们称之为发生冲突，go使用链地址法解决冲突，由于每一个bmap只能存储8个冲突的键值对，超过8个时，就分配一个新的bmap，下图展示冲突后的map 冲突不是一件好事，它降低存取效率。 4、冲突因子 冲突因子用于衡量一个hash表的冲突情况，公式为：负载因子=键数量 / bucket数量 如果负载因子过大，说明空间利用率低，反之冲突严重，存取效率低。 当hash表的负载因子过大时，需要申请更多的bucket，并对所有的键值对重新组织，使其均匀的分布到这些buket中，这个过程位rehash。 不同hash表的实现对负载因子的容忍程度不同，比如redis的map实现中负载因子大于1时就会触发rehash，而go的map则在负载因子达到6.5时触发rehash，因为redis的每个bucket只能存1个键值对，而go的map可以容忍更大的负载因子。 5、扩容 1）、扩容条件 降低负载因子常用的手段是扩容，当新元素要添加到map时会检查是否要扩容，扩容实际上是空间换时间的手段。 触发扩容需要满足以下任一条件： 负载因子大于6.5时，即平均每个bucket存储到的键值对达到6.5个以上。 overflow的数量大于2的15次方，即overflow的数量超过32768。 2）、增量扩容 如果map存储了数以亿计的键值对，一次性搬迁会造成比较大的延时，所以go采用了逐步搬迁的策略，即每次访问map时会触发一次搬迁，每次搬迁2个键值对。下图包含了1个bucket满载的map。 当前map存储了7个键值对，只有1个bucket，因此负载因子为7，再次添加数据时会触发扩容，扩容之后再将新的键值对写入新的bucket中，当添加第8个键值对时，扩容后的示意图如下： 扩容时的处理非常巧妙，先是让hmap数据结构中的oldbuckets成员指向原buckets数组，然后申请新的bucket数组（长度为原来的2倍），并将数组指针保存到hmap数据结构中的bucktets成员中，这样就完成了新老buckets数组的交换，后续的迁移工作是从oldbuckets数组中逐步搬迁键值对到新的buckets数组中。待oldbuckest数组中的所有键值对搬迁完毕后，就可以安全的释放oldbuckets数组了。 6、增删查改 1）、查询 根据key值计算hash值，取hash值的低位与hmap.B取模来确定bucket的位置，取hash值高位，在tophash数组中查询；如果tophash[i]中存储的hash值与当前key 的Hash值相同，则获取tophash[i]的key值进行比较。如果当前bucket中没有找到，则从溢出bucket中查询。 注意：如果当前map在搬迁过程中，则优先从oldbuckets数组中查找，不再从新的buckets数组中查找。 2）、更新、增加 根据key值计算hash值，取hash值的低位与hmap.B取模来确定bucket的位置，查找该key是否已经存在，如果存在则直接更新值。如果key不存在，则从该bucket中寻找空余位置并插入。 注意：如果当前map处于搬迁过程中，那么新元素会直接添加到新的buckets数组中，但是查找过程仍然从oldbuckets数组中开始。 3）、删除 删除元素实际上是先查找元素，如果元素存在则把元素从相同的bucket中清理，否则什么都不做。 ","link":"https://lsm424.github.io/post/map-shi-xian-yuan-li/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://lsm424.github.io/post/hello-gridea/"}]}