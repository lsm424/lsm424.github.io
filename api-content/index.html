{"posts":[{"title":"map实现原理","content":"map使用Hash表作为底层实现，一个Hash表可以有多个bucket，而每个bucket保存了map中的一个或一组键值对 1、map的数据结构 map的数据结构由runtime/map.go:hmap 定义 type hmap struct { count int // 当前保存的元素 B uint8 // bucket数组的大小 buckets unsafe.Pointer // bucket数组，数组的长度为2的B次方 oldbuckets unsafe.Pointer // 老旧bucket数组，用于扩容 ... } 如下展示了一个拥有4个bucket的map 本例中，由于B=2，所以buckets数组的长读为4（2的2次方），元素通过hash运算后会落到谬个bucket中进行存储。 2、bucket的数据结构 bucket的数据结构由runtime/map.go：bmap 定义： type bmap struct { tophash [8]uint8 // 存储hash值的高8位 data []byte // key value数据：key/key/key/.../value/value/value... overflow *hmap // 溢出bucket的地址 } 每个bucket可以存储8个键值对。tophash是一个长度为8的整形数组，Hash值低位相同的键存入当前bucket时会将Hash值的高位存储在该数组中，以便后续匹配。 data存key value数据，它的存放顺序是为了节省字节对齐带来的空间浪费。overflow指针指向的是下一个bucket，据此将所有冲突的键连接起来。 下图展示了bucket存放了8个key-value对 3、Hash冲突 当两个相同key被Hash到同一个bucket时，我们称之为发生冲突，go使用链地址法解决冲突，由于每一个bmap只能存储8个冲突的键值对，超过8个时，就分配一个新的bmap，下图展示冲突后的map 冲突不是一件好事，它降低存取效率。 4、冲突因子 冲突因子用于衡量一个hash表的冲突情况，公式为：负载因子=键数量 / bucket数量 如果负载因子过大，说明空间利用率低，反之冲突严重，存取效率低。 当hash表的负载因子过大时，需要申请更多的bucket，并对所有的键值对重新组织，使其均匀的分布到这些buket中，这个过程位rehash。 不同hash表的实现对负载因子的容忍程度不同，比如redis的map实现中负载因子大于1时就会触发rehash，而go的map则在负载因子达到6.5时触发rehash，因为redis的每个bucket只能存1个键值对，而go的map可以容忍更大的负载因子。 5、扩容 1）、扩容条件 降低负载因子常用的手段是扩容，当新元素要添加到map时会检查是否要扩容，扩容实际上是空间换时间的手段。 触发扩容需要满足以下任一条件： 负载因子大于6.5时，即平均每个bucket存储到的键值对达到6.5个以上。 overflow的数量大于2的15次方，即overflow的数量超过32768。 2）、增量扩容 如果map存储了数以亿计的键值对，一次性搬迁会造成比较大的延时，所以go采用了逐步搬迁的策略，即每次访问map时会触发一次搬迁，每次搬迁2个键值对。下图包含了1个bucket满载的map。 当前map存储了7个键值对，只有1个bucket，因此负载因子为7，再次添加数据时会触发扩容，扩容之后再将新的键值对写入新的bucket中，当添加第8个键值对时，扩容后的示意图如下： 扩容时的处理非常巧妙，先是让hmap数据结构中的oldbuckets成员指向原buckets数组，然后申请新的bucket数组（长度为原来的2倍），并将数组指针保存到hmap数据结构中的bucktets成员中，这样就完成了新老buckets数组的交换，后续的迁移工作是从oldbuckets数组中逐步搬迁键值对到新的buckets数组中。待oldbuckest数组中的所有键值对搬迁完毕后，就可以安全的释放oldbuckets数组了。 6、增删查改 1）、查询 根据key值计算hash值，取hash值的低位与hmap.B取模来确定bucket的位置，取hash值高位，在tophash数组中查询；如果tophash[i]中存储的hash值与当前key 的Hash值相同，则获取tophash[i]的key值进行比较。如果当前bucket中没有找到，则从溢出bucket中查询。 注意：如果当前map在搬迁过程中，则优先从oldbuckets数组中查找，不再从新的buckets数组中查找。 2）、更新、增加 根据key值计算hash值，取hash值的低位与hmap.B取模来确定bucket的位置，查找该key是否已经存在，如果存在则直接更新值。如果key不存在，则从该bucket中寻找空余位置并插入。 注意：如果当前map处于搬迁过程中，那么新元素会直接添加到新的buckets数组中，但是查找过程仍然从oldbuckets数组中开始。 3）、删除 删除元素实际上是先查找元素，如果元素存在则把元素从相同的bucket中清理，否则什么都不做。 ","link":"https://lsm424.github.io/post/map-shi-xian-yuan-li/"},{"title":"slice实现原理","content":"切片依托数组实现，底层数组对用户屏蔽，在底层数据容量不足时可以实现自动重分配并生成新的slice 1、数据结构 源码包中src/runtime/slice.go: slice 定义了slice的数据结构： type slice struct { array unsafe.Pointer len int cap int } 从数据结构上看slice很清晰，array指针指向底层数组，len表示切片长度，cap表示底层数组容量 2、切片操作 1）、使用make创建slice 可同时指定长度和容量，底层分配一个数组，数组的长度为容量，例如：slice := make([]int, 5, 10)，所创建的slice结构如下 该slice长度为5，可使用下标slice[0]~slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新元素不必重新分配内容，直到预留内存不足时再扩容 2)、使用数组创建slice 使用数组创建slice时，slice将与原数组共用一部分内存，例如slice := array[5:7]语句所创建的slice结构如下： 切片从数据array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5，意味着数组和切片共享底层内存 3）、切片扩容 使用append向slice追加元素时，如果slice空间不足，则会触发slice扩容，扩容实际上是重新分配一个更大的内存，将原slice的数组拷贝进新的slice，然后返回新的slice，扩容后再将数据追加进去。例如向一个 cap为5且len也为5的slice再次追加1个元素时，就会发生扩容 扩容影响cap，会把数据拷贝到新的slice中，追加数据由append在扩容结束后完成，由上图可见，slice的长度为5，但是容量由5变成10，原来slice中的数据也都拷贝到了新的slice指向的数组中。 扩容的选择遵循以下原则： 如果原slice的cap小雨1024，则新的容量扩大到原来的2倍。这种采用较大的扩容倍速，可以避免频繁扩容，从而减少内存分配次数和数据拷贝的代价 如果原slice的cap大于等于1024，则新的容量扩大到原来的1.25倍。这种采用较小的扩容倍速，可以避免浪费空间 同时还会考虑元素类型与内存分配原则，对实际扩张做一些微调。 4)、一些建议 创建切片可以根据实际需要分配容量，尽量避免在append过程中扩容，有利于提升性能。 拷贝切片时需要判断实际拷贝的元素个数 谨慎使用多个切片操作同一个数组，以防止读写冲突。 ","link":"https://lsm424.github.io/post/slice-shi-xian-yuan-li/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://lsm424.github.io/post/hello-gridea/"}]}