<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lsm424.github.io</id>
    <title>lsm424的博客</title>
    <updated>2022-02-06T09:11:26.373Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lsm424.github.io"/>
    <link rel="self" href="https://lsm424.github.io/atom.xml"/>
    <subtitle>怕什么真理无穷，进一寸有一寸的欢喜</subtitle>
    <logo>https://lsm424.github.io/images/avatar.png</logo>
    <icon>https://lsm424.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, lsm424的博客</rights>
    <entry>
        <title type="html"><![CDATA[树莓派装机]]></title>
        <id>https://lsm424.github.io/post/shu-mei-pai-zhuang-ji/</id>
        <link href="https://lsm424.github.io/post/shu-mei-pai-zhuang-ji/">
        </link>
        <updated>2022-01-31T14:20:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-下载镜像">1、下载镜像</h1>
<p>一般选择从官方的镜像 Raspbian OS，但是官网的比较慢，一般选择国内镜像下载，有两个：</p>
<ul>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os-images/">TUNA镜像站</a></li>
<li><a href="https://mirrors.sjtug.sjtu.edu.cn/raspberry-pi-os-images/">SJTUG镜像站</a></li>
</ul>
<p>同一个版本的镜像分为三种：</p>
<ul>
<li><strong>Raspberry Pi OS with desktop</strong> 即桌面版，1G左右大小，包含基本的软件</li>
<li><strong>Raspberry Pi OS with desktop and recommended software</strong>即full版本，包含一些办公软件，会比较大，3G左右，</li>
<li><strong>Raspberry Pi OS Lite</strong>即轻量级版，不带桌面，不到500M</li>
</ul>
<p>一般选择大小中等的桌面版，因为full版本太大，刷机时间以及磁盘占用都增加，包含的软件一般实际用不到，除非真的是办公使用，而轻量级版本缺少桌面，在一些配置方面不是很方面。常用的桌面版直达门：<br>
<a href="https://mirrors.sjtug.sjtu.edu.cn/raspberry-pi-os-images/raspios_armhf/images/raspios_armhf-2021-11-08/2021-10-30-raspios-bullseye-armhf.zip">2021-10-30 推荐版</a></p>
<h1 id="2-下载刷镜像软件raspberry-pi-imager">2、下载刷镜像软件Raspberry Pi Imager</h1>
<p>到官网下载刷机软件：https://www.raspberrypi.com/software/<br>
软件直达门<br>
<a href="https://downloads.raspberrypi.org/imager/imager_1.6.2.exe">windows版本</a><br>
<a href="https://downloads.raspberrypi.org/imager/imager_1.6.2.dmg">mac版本</a></p>
<h1 id="3-刷机">3、刷机</h1>
<p>可以使用u盘或者sd卡刷机，对于这二者方式的刷机和启动没有任何区别。树莓派会优先从sd卡启动，没有的话就会使用usb接口启动。</p>
<h2 id="31-刷机步骤">3.1 刷机步骤：</h2>
<p>将u盘或者tf卡插入电脑，启动上一步下载的Raspberry Pi Imager，选择刚插入的磁盘，再选择第一步下载的镜像，点击write，等待10分钟左右完成。</p>
<h2 id="32-重新刷机">3.2 重新刷机</h2>
<p>进入windows的磁盘管理或者使用diskgenius，清理分区（包括boot、root分区），重新新建分区，再格式化，最后再重新按照上一步刷机。</p>
<h2 id="33-常见问题">3.3 常见问题</h2>
<h3 id="331-刷机后我的磁盘怎么变小了">3.3.1 刷机后我的磁盘怎么变小了</h3>
<p>刷机后，windows你可能上看到十几个G的u盘或者sd卡只有200M了，不要惊慌！这是因为linux的分区在windows下看不到。装了Linux系统之后，SD卡会分成三种格式的分区，分别是：FAT32、EXT3、SWAP2。<br>
Ext3区属于linux的文件系统，就和win的系统盘C盘一样<br>
Swap区为linux的虚拟内存区，主要在物理内存不够用的时候，做缓存用的。<br>
以上两个，是Linux系统的分区。<br>
FAT32就是那“200M”了</p>
<h3 id="332-到底用u盘还是sd卡呢">3.3.2 到底用u盘还是sd卡呢</h3>
<p>经验表明：<strong>使用tf卡会十分卡顿</strong>，第一次开机都要三四分钟，<strong>使用了ssd的移动硬盘接usb3.0速度超快</strong>，开机速度10秒左右，测试过ssd的读写速度如下：</p>
<pre><code>pi@raspberrypi:~ $ dd if=/dev/zero of=/tmp/output.img bs=4k count=256k
记录了262144+0 的读入
记录了262144+0 的写出
1073741824字节（1.1 GB，1.0 GiB）已复制，5.59087 s，192 MB/s
pi@raspberrypi:~ $ dd if=/tmp/output.img bs=4k of=/dev/null
记录了262144+0 的读入
记录了262144+0 的写出
1073741824字节（1.1 GB，1.0 GiB）已复制，4.06454 s，264 MB/s
</code></pre>
<p>从上面测试结果可以看出，写入速度192MB/s，读取速度264MB/s！</p>
<h3 id="333-有时刷机出现锁该卷时发生错误-错误5-拒绝访问">3.3.3 有时刷机出现“锁该卷时发生错误 错误5 拒绝访问”</h3>
<p>win+R进入cmd指向如下命令：<br>
1、diskpart<br>
2、list disk  # 查看所有磁盘，找到u盘或者sd卡所在的磁盘编号<br>
3、select disk 2   # 2要改成具体你所使用磁盘的编号<br>
4、clean</p>
<h1 id="4-启动并设置ssh">4、启动并设置ssh</h1>
<p>插入sd卡或者u盘，接上hdmi显示器，耐心等待一会（期间可能会有短暂黑屏），会出现桌面，第一次登录会引导设置语言、pi用户密码、wifi、以及软件更新（这一步建议跳过）.</p>
<h1 id="5-设置ssh-vnc">5、设置ssh、vnc</h1>
<p>设置ssh、vnc，方面后续无线连接进行开发<br>
进入rasp-config<br>
<img src="https://lsm424.github.io/post-images/1643643523857.png" alt="" width="400" loading="lazy"><br>
将下列ssh、vnc勾选，启动服务<br>
<img src="https://lsm424.github.io/post-images/1643643643084.png" alt="" width="400" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[map实现原理]]></title>
        <id>https://lsm424.github.io/post/map-shi-xian-yuan-li/</id>
        <link href="https://lsm424.github.io/post/map-shi-xian-yuan-li/">
        </link>
        <updated>2022-01-29T07:16:53.000Z</updated>
        <content type="html"><![CDATA[<p><strong>map使用Hash表作为底层实现，一个Hash表可以有多个bucket，而每个bucket保存了map中的一个或一组键值对</strong></p>
<h1 id="1-map的数据结构">1、map的数据结构</h1>
<p>  map的数据结构由runtime/map.go:hmap 定义</p>
<pre><code>type hmap struct {
    count int  // 当前保存的元素
    B  uint8  // bucket数组的大小
    buckets  unsafe.Pointer  // bucket数组，数组的长度为2的B次方
    oldbuckets unsafe.Pointer  // 老旧bucket数组，用于扩容
    ...
}
</code></pre>
<p>如下展示了一个拥有4个bucket的map<br>
<img src="https://lsm424.github.io/post-images/1643440828994.jpg" alt="" width="500" loading="lazy"><br>
本例中，由于B=2，所以buckets数组的长读为4（2的2次方），元素通过hash运算后会落到谬个bucket中进行存储。</p>
<h1 id="2-bucket的数据结构">2、bucket的数据结构</h1>
<p>  bucket的数据结构由runtime/map.go：bmap 定义：</p>
<pre><code>type bmap struct {
    tophash [8]uint8  // 存储hash值的高8位
    data  []byte  // key value数据：key/key/key/.../value/value/value...
    overflow *hmap   // 溢出bucket的地址
}
</code></pre>
<p>  每个bucket可以存储8个键值对。tophash是一个长度为8的整形数组，Hash值低位相同的键存入当前bucket时会将Hash值的高位存储在该数组中，以便后续匹配。 data存key value数据，它的存放顺序是为了节省字节对齐带来的空间浪费。overflow指针指向的是下一个bucket，据此将所有冲突的键连接起来。</p>
<p>下图展示了bucket存放了8个key-value对<br>
<img src="https://lsm424.github.io/post-images/1643441145328.jpg" alt="" width="500" loading="lazy"></p>
<h1 id="3-hash冲突">3、Hash冲突</h1>
<p>  当两个相同key被Hash到同一个bucket时，我们称之为发生冲突，go使用链地址法解决冲突，由于每一个bmap只能存储8个冲突的键值对，超过8个时，就分配一个新的bmap，下图展示冲突后的map<br>
<img src="https://lsm424.github.io/post-images/1643441260079.jpg" alt="" width="650" loading="lazy"><br>
冲突不是一件好事，它降低存取效率。</p>
<h1 id="4-冲突因子">4、冲突因子</h1>
<p>  冲突因子用于衡量一个hash表的冲突情况，公式为：<code>负载因子=键数量 / bucket数量</code><br>
  如果负载因子过大，说明空间利用率低，反之冲突严重，存取效率低。<br>
  当hash表的负载因子过大时，需要申请更多的bucket，并对所有的键值对重新组织，使其均匀的分布到这些buket中，这个过程位rehash。<br>
  不同hash表的实现对负载因子的容忍程度不同，比如redis的map实现中负载因子大于1时就会触发rehash，而go的map则在负载因子达到6.5时触发rehash，因为redis的每个bucket只能存1个键值对，而go的map可以容忍更大的负载因子。</p>
<h1 id="5-扩容">5、扩容</h1>
<h2 id="1-扩容条件">1）、扩容条件</h2>
<p>  降低负载因子常用的手段是扩容，当新元素要添加到map时会检查是否要扩容，扩容实际上是空间换时间的手段。<br>
  触发扩容需要满足以下任一条件：</p>
<ul>
<li>负载因子大于6.5时，即平均每个bucket存储到的键值对达到6.5个以上。</li>
<li>overflow的数量大于2的15次方，即overflow的数量超过32768。</li>
</ul>
<h2 id="2-增量扩容">2）、增量扩容</h2>
<p>  如果map存储了数以亿计的键值对，一次性搬迁会造成比较大的延时，所以go采用了逐步搬迁的策略，即每次访问map时会触发一次搬迁，每次搬迁2个键值对。下图包含了1个bucket满载的map。<br>
<img src="https://lsm424.github.io/post-images/1643450425464.jpg" alt="" width="650" loading="lazy"><br>
  当前map存储了7个键值对，只有1个bucket，因此负载因子为7，再次添加数据时会触发扩容，扩容之后再将新的键值对写入新的bucket中，当添加第8个键值对时，扩容后的示意图如下：<br>
<img src="https://lsm424.github.io/post-images/1643450462801.jpg" alt="" width="650" loading="lazy"><br>
  扩容时的处理非常巧妙，先是让hmap数据结构中的oldbuckets成员指向原buckets数组，然后申请新的bucket数组（长度为原来的2倍），并将数组指针保存到hmap数据结构中的bucktets成员中，这样就完成了新老buckets数组的交换，后续的迁移工作是从oldbuckets数组中逐步搬迁键值对到新的buckets数组中。待oldbuckest数组中的所有键值对搬迁完毕后，就可以安全的释放oldbuckets数组了。</p>
<h1 id="6-增删查改">6、增删查改</h1>
<h2 id="1-查询">1）、查询</h2>
<p>  根据key值计算hash值，取hash值的低位与hmap.B取模来确定bucket的位置，取hash值高位，在tophash数组中查询；如果tophash[i]中存储的hash值与当前key 的Hash值相同，则获取tophash[i]的key值进行比较。如果当前bucket中没有找到，则从溢出bucket中查询。</p>
<p><em>注意：如果当前map在搬迁过程中，则优先从oldbuckets数组中查找，不再从新的buckets数组中查找。</em></p>
<h2 id="2-更新-增加">2）、更新、增加</h2>
<p>  根据key值计算hash值，取hash值的低位与hmap.B取模来确定bucket的位置，查找该key是否已经存在，如果存在则直接更新值。如果key不存在，则从该bucket中寻找空余位置并插入。</p>
<p><em>注意：如果当前map处于搬迁过程中，那么新元素会直接添加到新的buckets数组中，但是查找过程仍然从oldbuckets数组中开始。</em></p>
<h2 id="3-删除">3）、删除</h2>
<p>  删除元素实际上是先查找元素，如果元素存在则把元素从相同的bucket中清理，否则什么都不做。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://lsm424.github.io/post/hello-gridea/</id>
        <link href="https://lsm424.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>